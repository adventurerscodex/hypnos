[
  {
    "__docId__": 1,
    "kind": "external",
    "name": "Infinity",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Infinity",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 2,
    "kind": "external",
    "name": "NaN",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~NaN",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 3,
    "kind": "external",
    "name": "undefined",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~undefined",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 4,
    "kind": "external",
    "name": "null",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~null",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 5,
    "kind": "external",
    "name": "Object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 6,
    "kind": "external",
    "name": "object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 7,
    "kind": "external",
    "name": "Function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 8,
    "kind": "external",
    "name": "function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 9,
    "kind": "external",
    "name": "Boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 10,
    "kind": "external",
    "name": "boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 11,
    "kind": "external",
    "name": "Symbol",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Symbol",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 12,
    "kind": "external",
    "name": "Error",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Error",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 13,
    "kind": "external",
    "name": "EvalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/EvalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~EvalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 14,
    "kind": "external",
    "name": "InternalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/InternalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~InternalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 15,
    "kind": "external",
    "name": "RangeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RangeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 16,
    "kind": "external",
    "name": "ReferenceError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ReferenceError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 17,
    "kind": "external",
    "name": "SyntaxError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~SyntaxError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 18,
    "kind": "external",
    "name": "TypeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~TypeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 19,
    "kind": "external",
    "name": "URIError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/URIError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~URIError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 20,
    "kind": "external",
    "name": "Number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 21,
    "kind": "external",
    "name": "number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 22,
    "kind": "external",
    "name": "Date",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Date",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 23,
    "kind": "external",
    "name": "String",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~String",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 24,
    "kind": "external",
    "name": "string",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~string",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 25,
    "kind": "external",
    "name": "RegExp",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RegExp",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 26,
    "kind": "external",
    "name": "Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 27,
    "kind": "external",
    "name": "Int8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 28,
    "kind": "external",
    "name": "Uint8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 29,
    "kind": "external",
    "name": "Uint8ClampedArray",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8ClampedArray",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 30,
    "kind": "external",
    "name": "Int16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 31,
    "kind": "external",
    "name": "Uint16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 32,
    "kind": "external",
    "name": "Int32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 33,
    "kind": "external",
    "name": "Uint32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 34,
    "kind": "external",
    "name": "Float32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 35,
    "kind": "external",
    "name": "Float64Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float64Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 36,
    "kind": "external",
    "name": "Map",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Map",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 37,
    "kind": "external",
    "name": "Set",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Set",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 38,
    "kind": "external",
    "name": "WeakMap",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakMap",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 39,
    "kind": "external",
    "name": "WeakSet",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakSet",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 40,
    "kind": "external",
    "name": "ArrayBuffer",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ArrayBuffer",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 41,
    "kind": "external",
    "name": "DataView",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~DataView",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 42,
    "kind": "external",
    "name": "JSON",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~JSON",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 43,
    "kind": "external",
    "name": "Promise",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Promise",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 44,
    "kind": "external",
    "name": "Generator",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Generator",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 45,
    "kind": "external",
    "name": "GeneratorFunction",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~GeneratorFunction",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 46,
    "kind": "external",
    "name": "Reflect",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Reflect",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 47,
    "kind": "external",
    "name": "Proxy",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Proxy",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 48,
    "kind": "file",
    "name": "src/hypnos.js",
    "content": "import APIResponse from './response';\nimport Cache from 'node-cache';\nimport coreapi from 'coreapi';\nimport hash from 'object-hash';\nimport schema from 'schema';\n\n/**\n * Hypnos is a light-weight ORM and API Client for Javascript Web Clients.\n *\n * It uses a CoreAPI client and a given API schema to allow clients easy access\n * to both raw response data and mapped custom Model objects.\n *\n * Hypnos returns all normal responses in the form of a APIResponse\n * which allows for easy navigation through paginated responses as well as automatic\n * mapping to custom Models (see `Model` and `APIResponse` for more information).\n *\n * Once a Model is mapped from a response, it is also registered with\n * Hypnos and has access to shortcut methods via it's `ps` property.\n *\n * Example\n * -------\n *\n *     Hypnos.client.retrieve(Book, { id: '1234' }).then(response => {\n *         const book = response.object;\n *         // Update the local properties of the book object.\n *         book.title('My new favorite book');\n *\n *         // Persist your changes back to the API.\n *         book.ps.save();\n *\n *         // ...You can even refresh your local object from the API.\n *         book.ps.refresh();\n *\n *         // ...Or delete it easily.\n *         book.ps.delete();\n *     });\n */\nexport class Hypnos {\n    static configuration = {};\n\n    static _client = null;\n\n    static get client() {\n        if (!Hypnos._client) {\n            Hypnos._client = new _Hypnos(\n                Hypnos.configuration.credentials,\n                Hypnos.configuration.schema,\n                Hypnos.configuration.cacheConfig\n            );\n        }\n        return Hypnos._client;\n    }\n\n    /**\n     * Flush the cache and destroy the current Hypnos client.\n     */\n    static flush() {\n        if (this.client.cache) {\n            this.client.cache.flushAll();\n        }\n        this._client = null;\n    }\n}\n\nclass _Hypnos {\n\n    constructor(credentials, schema, cacheConfig) {\n        this.schema = schema;\n\n        if (cacheConfig) {\n            this.cache = new Cache(cacheConfig);\n        }\n\n        // Initialize the CoreAPI Client\n        const auth = new coreapi.auth.TokenAuthentication(credentials);\n        this.client = new coreapi.Client({ auth: auth });\n    }\n\n    /**\n     * TODO: Document\n     */\n    action = async ({ keys, params, raw, useCache=false, flushDepsCache=true, model=null, many=false }) => {\n        // If we can and should, prefer the cache.\n        if (this.cache && useCache) {\n            const key = this.cacheKey(model, keys, params, raw);\n            const cachedValue = this.cache.get(key);\n\n            if (cachedValue !== undefined) {\n                return raw ? cachedValue : new APIResponse({\n                    data: cachedValue,\n                    keys,\n                    params,\n                    model,\n                    fromCache: true,\n                    many,\n                });\n            }\n        }\n\n        const data = await this.client.action(this.schema, keys, params);\n\n        // If we should, store the new value in the cache.\n        if (this.cache && useCache) {\n            const key = this.cacheKey(model, keys, params, raw);\n            this.cache.set(key, data);\n        }\n\n        // If this is a model-based request and we should clear the dep cache, do so.\n        if (this.cache && model && flushDepsCache) {\n            const dependents = model.getDependents();\n            const dependentKeys = this.cache.keys().filter(key => (\n                dependents.some(dependent => {\n                    if (typeof dependent === 'string') {\n                        // The dependent was specified as a string.\n                        return key.indexOf(dependent) == 0;\n                    } else {\n                        // The dependent was specified as a model.\n                        return key.indexOf(dependent.name) == 0;\n                    }\n                })\n            ));\n            this.cache.del(dependentKeys);\n        }\n\n        return raw ? data : new APIResponse({ data, keys, params, model, many });\n    };\n\n    cacheKey = (model, ...keys) => {\n        let key = (model && model.name) ? `${model.name}__` : '';\n        key += hash(keys);\n        return key;\n    };\n\n    /**\n     * API Operations Methods\n     * ======================\n     * The following methods allow for easy interaction with the backing API\n     * using the provided API Schema.\n     * If you need functionality beyond the scope of these methods, refer to\n     * the lower-level `action` API which simply wraps the coreapi.Client and\n     * returns a APIResponse.\n     *\n     * Unmapped Responses\n     * ------------------\n     * To perform the query without mapping the results to a APIResponse set\n     * `raw` to true. This will return the JSON results of the query directly.\n     *\n     * Using Custom Models\n     * -------------------\n     * Most times it is easiest to use subclasses of the base `Model` type\n     * (see Model for more information), and if you need to provide a custom\n     * object, you can refer to the `Model` documentation to see what fields\n     * are required in order to conform with the Hypnos API.\n     */\n\n    /**\n     * Given a model type and an optional set of parameters, perform a list query\n     * against the backing API and return a promise of results in the form of a\n     * APIResponse (see APIResponse for more information).\n     *\n     * Example\n     * -------\n     *\n     *     Hypnos.list(Book).then(response => {\n     *         const books = response.objects;\n     *         // Do stuff with books...\n     *     });\n     */\n    list = async (model, params={}, raw=false, useCache=true, flushDepsCache=false) => {\n        const keys = [...model.__skeys__, 'list'];\n        return await this.action({ keys, params, raw, model, many: true, useCache, flushDepsCache });\n    };\n\n    /**\n     * Given a model type and an optional set of parameters, perform a retrieve\n     * query against the backing API and return a promise of results in the\n     * form of a APIResponse (see APIResponse for more information).\n     *\n     * Example\n     * -------\n     *\n     *     Hypnos.client.read(Book, { id: '1234' }).then(response => {\n     *         const book = response.object;\n     *         // Do stuff with your book...\n     *     });\n     */\n    read = async (model, params={}, raw=false, useCache=true, flushDepsCache=false) => {\n        const keys = [...model.__skeys__, 'read'];\n        return await this.action({ keys, params, raw, model, many: false, useCache, flushDepsCache });\n    };\n\n    /**\n     * Given a model type and an optional set of parameters, perform a create\n     * against the backing API and return a promise of results in the\n     * form of a APIResponse (see APIResponse for more information).\n     *\n     * Example\n     * -------\n     *\n     *     const data = { title: 'An Adventure', author: 'John Smith' };\n     *     Hypnos.client.create(Book, data).then(response => {\n     *         const book = response.object;\n     *         // Do stuff with your new book...\n     *     });\n     */\n    create = async (model, params={}, raw=false) => {\n        const keys = [...model.__skeys__, 'create'];\n        return await this.action({ keys, params, raw, model, many: false });\n    };\n\n    /**\n     * Given a model type and an optional set of parameters, perform an update\n     * against the backing API and return a promise of results in the\n     * form of a APIResponse (see APIResponse for more information).\n     *\n     * Example\n     * -------\n     *\n     *     const data = { id: '1234', title: 'An Adventure II', author: 'John Smith' };\n     *     Hypnos.client.update(Book, data).then(response => {\n     *         const book = response.object;\n     *         // Do stuff with your updated book...\n     *     });\n     */\n    update = async (model, params={}, raw=false) => {\n        const keys = [...model.__skeys__, 'update'];\n        return await this.action({ keys, params, raw, model, many: false });\n    };\n\n    /**\n     * Given a model type and an optional set of parameters, perform a destroy\n     * against the backing API and return a promise of results in the\n     * form of a APIResponse (see APIResponse for more information).\n     *\n     * Example\n     * -------\n     *\n     *     Hypnos.delete(Book, { id: '1234' });\n     */\n    delete = async (model, params={}, raw=false) => {\n        const keys = [...model.__skeys__, 'delete'];\n        return await this.action({ keys, params, raw, model, many: false });\n    };\n}\n",
    "static": true,
    "longname": "/Users/ifoundit/Projects/adventurers_codex/hypnos/src/hypnos.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 49,
    "kind": "class",
    "name": "Hypnos",
    "memberof": "src/hypnos.js",
    "static": true,
    "longname": "src/hypnos.js~Hypnos",
    "access": "public",
    "export": true,
    "importPath": "hypnos/src/hypnos.js",
    "importStyle": "{Hypnos}",
    "description": "Hypnos is a light-weight ORM and API Client for Javascript Web Clients.\n\nIt uses a CoreAPI client and a given API schema to allow clients easy access\nto both raw response data and mapped custom Model objects.\n\nHypnos returns all normal responses in the form of a APIResponse\nwhich allows for easy navigation through paginated responses as well as automatic\nmapping to custom Models (see `Model` and `APIResponse` for more information).\n\nOnce a Model is mapped from a response, it is also registered with\nHypnos and has access to shortcut methods via it's `ps` property.\n\nExample\n-------\n\n    Hypnos.client.retrieve(Book, { id: '1234' }).then(response => {\n        const book = response.object;\n        // Update the local properties of the book object.\n        book.title('My new favorite book');\n\n        // Persist your changes back to the API.\n        book.ps.save();\n\n        // ...You can even refresh your local object from the API.\n        book.ps.refresh();\n\n        // ...Or delete it easily.\n        book.ps.delete();\n    });",
    "lineNumber": 38,
    "interface": false
  },
  {
    "__docId__": 50,
    "kind": "member",
    "name": "configuration",
    "memberof": "src/hypnos.js~Hypnos",
    "static": true,
    "longname": "src/hypnos.js~Hypnos.configuration",
    "access": "public",
    "description": null,
    "lineNumber": 39,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 51,
    "kind": "member",
    "name": "_client",
    "memberof": "src/hypnos.js~Hypnos",
    "static": true,
    "longname": "src/hypnos.js~Hypnos._client",
    "access": "private",
    "description": null,
    "lineNumber": 41,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 52,
    "kind": "get",
    "name": "client",
    "memberof": "src/hypnos.js~Hypnos",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/hypnos.js~Hypnos.client",
    "access": "public",
    "description": null,
    "lineNumber": 43,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 53,
    "kind": "method",
    "name": "flush",
    "memberof": "src/hypnos.js~Hypnos",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/hypnos.js~Hypnos.flush",
    "access": "public",
    "description": "Flush the cache and destroy the current Hypnos client.",
    "lineNumber": 57,
    "params": [],
    "return": null
  },
  {
    "__docId__": 55,
    "kind": "class",
    "name": "_Hypnos",
    "memberof": "src/hypnos.js",
    "static": true,
    "longname": "src/hypnos.js~_Hypnos",
    "access": "private",
    "export": false,
    "importPath": "hypnos/src/hypnos.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 65,
    "undocument": true,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 56,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/hypnos.js~_Hypnos",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/hypnos.js~_Hypnos#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 67,
    "undocument": true
  },
  {
    "__docId__": 57,
    "kind": "member",
    "name": "schema",
    "memberof": "src/hypnos.js~_Hypnos",
    "static": false,
    "longname": "src/hypnos.js~_Hypnos#schema",
    "access": "public",
    "description": null,
    "lineNumber": 68,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 58,
    "kind": "member",
    "name": "cache",
    "memberof": "src/hypnos.js~_Hypnos",
    "static": false,
    "longname": "src/hypnos.js~_Hypnos#cache",
    "access": "public",
    "description": null,
    "lineNumber": 71,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 59,
    "kind": "member",
    "name": "client",
    "memberof": "src/hypnos.js~_Hypnos",
    "static": false,
    "longname": "src/hypnos.js~_Hypnos#client",
    "access": "public",
    "description": null,
    "lineNumber": 76,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 60,
    "kind": "member",
    "name": "action",
    "memberof": "src/hypnos.js~_Hypnos",
    "static": false,
    "longname": "src/hypnos.js~_Hypnos#action",
    "access": "public",
    "description": "TODO: Document",
    "lineNumber": 82,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 61,
    "kind": "member",
    "name": "cacheKey",
    "memberof": "src/hypnos.js~_Hypnos",
    "static": false,
    "longname": "src/hypnos.js~_Hypnos#cacheKey",
    "access": "public",
    "description": null,
    "lineNumber": 128,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 62,
    "kind": "member",
    "name": "list",
    "memberof": "src/hypnos.js~_Hypnos",
    "static": false,
    "longname": "src/hypnos.js~_Hypnos#list",
    "access": "public",
    "description": "Given a model type and an optional set of parameters, perform a list query\nagainst the backing API and return a promise of results in the form of a\nAPIResponse (see APIResponse for more information).\n\nExample\n-------\n\n    Hypnos.list(Book).then(response => {\n        const books = response.objects;\n        // Do stuff with books...\n    });",
    "lineNumber": 169,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 63,
    "kind": "member",
    "name": "read",
    "memberof": "src/hypnos.js~_Hypnos",
    "static": false,
    "longname": "src/hypnos.js~_Hypnos#read",
    "access": "public",
    "description": "Given a model type and an optional set of parameters, perform a retrieve\nquery against the backing API and return a promise of results in the\nform of a APIResponse (see APIResponse for more information).\n\nExample\n-------\n\n    Hypnos.client.read(Book, { id: '1234' }).then(response => {\n        const book = response.object;\n        // Do stuff with your book...\n    });",
    "lineNumber": 187,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 64,
    "kind": "member",
    "name": "create",
    "memberof": "src/hypnos.js~_Hypnos",
    "static": false,
    "longname": "src/hypnos.js~_Hypnos#create",
    "access": "public",
    "description": "Given a model type and an optional set of parameters, perform a create\nagainst the backing API and return a promise of results in the\nform of a APIResponse (see APIResponse for more information).\n\nExample\n-------\n\n    const data = { title: 'An Adventure', author: 'John Smith' };\n    Hypnos.client.create(Book, data).then(response => {\n        const book = response.object;\n        // Do stuff with your new book...\n    });",
    "lineNumber": 206,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 65,
    "kind": "member",
    "name": "update",
    "memberof": "src/hypnos.js~_Hypnos",
    "static": false,
    "longname": "src/hypnos.js~_Hypnos#update",
    "access": "public",
    "description": "Given a model type and an optional set of parameters, perform an update\nagainst the backing API and return a promise of results in the\nform of a APIResponse (see APIResponse for more information).\n\nExample\n-------\n\n    const data = { id: '1234', title: 'An Adventure II', author: 'John Smith' };\n    Hypnos.client.update(Book, data).then(response => {\n        const book = response.object;\n        // Do stuff with your updated book...\n    });",
    "lineNumber": 225,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 66,
    "kind": "member",
    "name": "delete",
    "memberof": "src/hypnos.js~_Hypnos",
    "static": false,
    "longname": "src/hypnos.js~_Hypnos#delete",
    "access": "public",
    "description": "Given a model type and an optional set of parameters, perform a destroy\nagainst the backing API and return a promise of results in the\nform of a APIResponse (see APIResponse for more information).\n\nExample\n-------\n\n    Hypnos.delete(Book, { id: '1234' });",
    "lineNumber": 240,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 67,
    "kind": "file",
    "name": "src/hypnos.spec.js",
    "content": "import { Author, Book } from './__mocks__/models';\nimport { Hypnos, KOModel } from './index';\nimport coreapi from 'coreapi';\nimport hash from 'object-hash';\nimport { mockedFetch } from './__helpers__/utils';\nimport schema from './__mocks__/schema';\n\nconst defaultConfiguration = {\n    schema,\n    credentials: {},\n    cacheConfig: {},\n};\n\ndescribe('Hypnos', () => {\n    beforeEach(() => {\n        Hypnos.flush();\n    });\n\n    it('should attempt an uncached API request', async () => {\n        const time = (new Date()).getTime();\n\n        const transport = new coreapi.transports.HTTPTransport({\n            fetch: mockedFetch(JSON.stringify({\n                time,\n            }), 'application/json')\n        });\n\n        Hypnos.configuration = { ...defaultConfiguration };\n        Hypnos.client.client = new coreapi.Client({ transports: [transport] });\n\n        const response = await Hypnos.client.action({\n            keys: ['books', 'list'],\n            params: {},\n        });\n\n        expect(response.fromCache).toBe(false);\n        expect(response.data.time).toEqual(time);\n    });\n\n    it('should attempt a cached API request after an uncached one', async () => {\n        const time = (new Date()).getTime();\n\n        const transport = new coreapi.transports.HTTPTransport({\n            fetch: mockedFetch(JSON.stringify({\n                time,\n            }), 'application/json')\n        });\n\n        Hypnos.configuration = {\n            ...defaultConfiguration,\n            cacheConfig: {\n                ttl: 0,\n            }\n        };\n        Hypnos.client.client = new coreapi.Client({ transports: [transport] });\n\n        const response1 = await Hypnos.client.action({\n            keys: ['books', 'list'],\n            params: {},\n            useCache: true,\n        });\n\n        expect(response1.fromCache).toBe(false);\n        expect(response1.data.time).toEqual(time);\n\n        // Do the same request again.\n        const response2 = await Hypnos.client.action({\n            keys: ['books', 'list'],\n            params: {},\n            useCache: true,\n        });\n\n        expect(response2.fromCache).toBe(true);\n        expect(response2.data.time).toEqual(time);\n    });\n\n    describe('Shortcut Actions', () => {\n        it('should attempt to list objects and cache the results', async () => {\n            const bookFixtures = [\n                {\n                    title: 'A Title',\n                    author: 'Me',\n                    isBestseller: false,\n                },\n                {\n                    title: 'Another Title',\n                    author: 'You',\n                    isBestseller: true,\n                },\n            ];\n\n            const transport = new coreapi.transports.HTTPTransport({\n                fetch: mockedFetch(JSON.stringify({ results: [...bookFixtures] }), 'application/json')\n            });\n            Hypnos.client.client = new coreapi.Client({ transports: [transport] });\n            Hypnos.configuration = { ...defaultConfiguration };\n\n            const response = await Hypnos.client.list(Book);\n\n            expect(response.fromCache).toBe(false);\n            expect(response.fetchParams).toEqual({});\n            expect(response.many).toEqual(true);\n\n            const book = response.objects[0];\n\n            expect(book.title).toEqual(bookFixtures[0].title);\n            expect(book.author).toEqual(bookFixtures[0].author);\n            expect(book.isBestseller).toEqual(bookFixtures[0].isBestseller);\n\n            // Check that the result was cached\n            const cachedValue = Hypnos.client.cache.get(Hypnos.client.cacheKey(\n                Book,\n                [...Book.__skeys__, 'list'],\n                {},\n                false,\n            ));\n\n            expect(cachedValue).toEqual({ results: [...bookFixtures] });\n        });\n\n        it('should attempt to retrieve an object and cache the result', async () => {\n            const bookFixture = {\n                uuid: '2345-676543-23456-6543',\n                title: 'A Title',\n                author: 'Me',\n                isBestseller: false,\n            };\n\n            const transport = new coreapi.transports.HTTPTransport({\n                fetch: mockedFetch(JSON.stringify({ ...bookFixture }), 'application/json')\n            });\n            Hypnos.client.client = new coreapi.Client({ transports: [transport] });\n            Hypnos.configuration = { ...defaultConfiguration };\n\n            const response = await Hypnos.client.read(Book, { uuid: bookFixture.uuid });\n\n            expect(response.fromCache).toBe(false);\n            expect(response.fetchParams).toEqual({ uuid: bookFixture.uuid });\n            expect(response.many).toEqual(false);\n\n            const book = response.object;\n\n            expect(book.title).toEqual(bookFixture.title);\n            expect(book.author).toEqual(bookFixture.author);\n            expect(book.isBestseller).toEqual(bookFixture.isBestseller);\n\n            // Check that the result was cached\n            const cachedValue = Hypnos.client.cache.get(Hypnos.client.cacheKey(\n                Book,\n                [...Book.__skeys__, 'read'],\n                { uuid: bookFixture.uuid },\n                false\n            ));\n\n            expect(cachedValue).toEqual(bookFixture);\n        });\n\n        it('should attempt to create an object and not cache the result', async () => {\n            const bookFixture = {\n                title: 'A Title',\n                author: 'Me',\n                isBestseller: false,\n            };\n\n            const transport = new coreapi.transports.HTTPTransport({\n                fetch: mockedFetch(JSON.stringify({ ...bookFixture }), 'application/json')\n            });\n            Hypnos.client.client = new coreapi.Client({ transports: [transport] });\n            Hypnos.configuration = { ...defaultConfiguration };\n\n            const response = await Hypnos.client.create(Book, { ...bookFixture });\n\n            expect(response.fromCache).toBe(false);\n            expect(response.fetchParams).toEqual(bookFixture);\n            expect(response.many).toEqual(false);\n\n            const book = response.object;\n\n            expect(book.title).toEqual(bookFixture.title);\n            expect(book.author).toEqual(bookFixture.author);\n            expect(book.isBestseller).toEqual(bookFixture.isBestseller);\n\n            // Check that the result was cached\n            const cachedValue = Hypnos.client.cache.get(Hypnos.client.cacheKey(\n                Book,\n                [...Book.__skeys__, 'create'],\n                { uuid: bookFixture.uuid },\n                false\n            ));\n\n            expect(cachedValue).toEqual(undefined);\n        });\n\n        it('should attempt to update an object and not cache the result', async () => {\n            const bookFixture = {\n                uuid: '2345-676543-23456-6543',\n                title: 'A Title',\n                author: 'Me',\n                isBestseller: false,\n            };\n\n            const transport = new coreapi.transports.HTTPTransport({\n                fetch: mockedFetch(JSON.stringify({ ...bookFixture }), 'application/json')\n            });\n            Hypnos.client.client = new coreapi.Client({ transports: [transport] });\n            Hypnos.configuration = { ...defaultConfiguration };\n\n            const response = await Hypnos.client.update(Book, { ...bookFixture });\n\n            expect(response.fromCache).toBe(false);\n            expect(response.fetchParams).toEqual(bookFixture);\n            expect(response.many).toEqual(false);\n\n            const book = response.object;\n\n            expect(book.title).toEqual(bookFixture.title);\n            expect(book.author).toEqual(bookFixture.author);\n            expect(book.isBestseller).toEqual(bookFixture.isBestseller);\n\n            // Check that the result was cached\n            const cachedValue = Hypnos.client.cache.get(Hypnos.client.cacheKey(\n                Book,\n                [...Book.__skeys__, 'update'],\n                { uuid: bookFixture.uuid },\n                false\n            ));\n\n            expect(cachedValue).toEqual(undefined);\n        });\n\n        it('should attempt to delete an object and not cache the result', async () => {\n            const bookFixture = {\n                uuid: '2345-676543-23456-6543',\n            };\n\n            const transport = new coreapi.transports.HTTPTransport({\n                fetch: mockedFetch(JSON.stringify({ ...bookFixture }), 'application/json')\n            });\n            Hypnos.client.client = new coreapi.Client({ transports: [transport] });\n            Hypnos.configuration = { ...defaultConfiguration };\n\n            const response = await Hypnos.client.delete(Book, { ...bookFixture });\n\n            expect(response.fromCache).toBe(false);\n            expect(response.fetchParams).toEqual(bookFixture);\n            expect(response.many).toEqual(false);\n\n            const book = response.object;\n\n            expect(book.uuid).toEqual(bookFixture.uuid);\n\n            // Check that the result was cached\n            const cachedValue = Hypnos.client.cache.get(Hypnos.client.cacheKey(\n                Book,\n                [...Book.__skeys__, 'delete'],\n                { uuid: bookFixture.uuid },\n                false\n            ));\n\n            expect(cachedValue).toEqual(undefined);\n        });\n    });\n\n    describe('Raw Results', () => {\n        it('should attempt to retrieve a raw response and cache the result', async () => {\n            const bookFixture = {\n                uuid: '2345-676543-23456-6543',\n                title: 'A Title',\n                author: 'Me',\n                isBestseller: false,\n            };\n\n            const transport = new coreapi.transports.HTTPTransport({\n                fetch: mockedFetch(JSON.stringify({ ...bookFixture }), 'application/json')\n            });\n            Hypnos.client.client = new coreapi.Client({ transports: [transport] });\n            Hypnos.configuration = { ...defaultConfiguration };\n\n            const data = await Hypnos.client.read(Book, { uuid: bookFixture.uuid }, true);\n\n            expect(data.title).toEqual(bookFixture.title);\n            expect(data.author).toEqual(bookFixture.author);\n            expect(data.isBestseller).toEqual(bookFixture.isBestseller);\n\n            // Check that the result was cached\n            const cachedValue = Hypnos.client.cache.get(Hypnos.client.cacheKey(\n                Book,\n                [...Book.__skeys__, 'read'],\n                { uuid: bookFixture.uuid },\n                true\n            ));\n\n            expect(cachedValue).toEqual(bookFixture);\n        });\n\n        it('should attempt to retrieve a raw response using the cached result', async () => {\n            const bookFixture = {\n                uuid: '2345-676543-23456-6543',\n                title: 'A Title',\n                author: 'Me',\n                isBestseller: false,\n            };\n\n            const transport = new coreapi.transports.HTTPTransport({\n                fetch: mockedFetch(JSON.stringify({ ...bookFixture }), 'application/json')\n            });\n            Hypnos.client.client = new coreapi.Client({ transports: [transport] });\n            Hypnos.configuration = { ...defaultConfiguration };\n\n            const data1 = await Hypnos.client.read(Book, { uuid: bookFixture.uuid }, true);\n\n            expect(data1.title).toEqual(bookFixture.title);\n            expect(data1.author).toEqual(bookFixture.author);\n            expect(data1.isBestseller).toEqual(bookFixture.isBestseller);\n\n            // Make a second request and ensure that the network was never used.\n            Hypnos.client.client.action = jest.fn();\n            const data2 = await Hypnos.client.read(Book, { uuid: bookFixture.uuid }, true);\n            expect(data2.title).toEqual(bookFixture.title);\n            expect(Hypnos.client.client.action).toHaveBeenCalledTimes(0);\n        });\n    });\n\n    describe('Cache Configurations', () => {\n        it('should validate that the cache config is being used', async () => {\n            Hypnos.configuration = {\n                ...defaultConfiguration,\n                cacheConfig: {\n                    stdTTL: 10,\n                    checkperiod: 10,\n                    errorOnMissing: true,\n                    useClones: false,\n                },\n            };\n\n            const client = Hypnos.client;\n\n            expect(client.cache.options.stdTTL).toEqual(10);\n            expect(client.cache.options.checkperiod).toEqual(10);\n            expect(client.cache.options.errorOnMissing).toEqual(true);\n            expect(client.cache.options.useClones).toEqual(false);\n        });\n    });\n\n    describe('Cache Key Generation', () => {\n        it('should validate that the cache key generation algorithm is correct', async () => {\n            const key1 = Hypnos.client.cacheKey(\n                Book,\n                ['an entry'],\n            );\n            expect(key1).toContain('Book__');\n        });\n        it('should validate that the cache key generation algorithm is correct when no model is used', async () => {\n            const key = Hypnos.client.cacheKey(\n                null,\n                ['an entry'],\n            );\n            expect(key).not.toContain('__');\n        });\n    });\n});\n",
    "static": true,
    "longname": "/Users/ifoundit/Projects/adventurers_codex/hypnos/src/hypnos.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 68,
    "kind": "variable",
    "name": "defaultConfiguration",
    "memberof": "src/hypnos.spec.js",
    "static": true,
    "longname": "src/hypnos.spec.js~defaultConfiguration",
    "access": "public",
    "export": false,
    "importPath": "hypnos/src/hypnos.spec.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "{\"schema\": *, \"credentials\": *, \"cacheConfig\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 69,
    "kind": "file",
    "name": "src/index.js",
    "content": "/* API Client */\n\nexport { Hypnos } from './hypnos';\nexport { APIResponse } from './response';\nexport { ModelToken, InstanceToken } from './tokens';\n\n/* Models */\n\nexport { BaseModel } from './models/base';\nexport { KOModel } from './models/ko';\nexport { Model } from './models/model';\n",
    "static": true,
    "longname": "/Users/ifoundit/Projects/adventurers_codex/hypnos/src/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 70,
    "kind": "file",
    "name": "src/index.spec.js",
    "content": "import { KOModel } from './index';\nimport coreapi from 'coreapi';\nimport schema from './__mocks__/schema';\n\ndescribe('Main Index', () => {\n    it('should import things', () => {\n        expect(KOModel).toBeDefined();\n    });\n});\n",
    "static": true,
    "longname": "/Users/ifoundit/Projects/adventurers_codex/hypnos/src/index.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 71,
    "kind": "file",
    "name": "src/models/base.js",
    "content": "import { InstanceToken, ModelToken } from '../tokens';\nimport { get, pick } from 'lodash';\nimport ko from 'knockout';\nimport schema from 'schema';\n\n\n/**\n * This class is the base definition of all ES6 style model objects.\n *\n * Models extending this class will gain the following benefits:\n * - Automatic Persistence Service Token registration.\n * - Automatic mapping via FetchResponses and mapped queries.\n *\n * This model provides no default implementation of serialization or\n * deserialization. Subclasses must implement this feature for their respective\n * use-cases. This framework provides a few default implementations of usable\n * model classes like: Model and KOModel.\n *\n * ## Mapping Models to the API Schema\n *\n * Once you have an API schema you'll need to specify how your model classes\n * map to the schema definition. You do this by specifying the path in the\n * model's `__skeys__` static attribute.\n *\n *      class Book extends Model {\n *          static __skeys__ = ['resources', 'books'];\n *      }\n *\n * ## Specifying Dependents\n *\n * Hypnos automatically takes care of caching and re-serving cached responses for\n * identical queries. If your API has situations where model data is altered by\n * changes to other referenced models in your API (i.e. if updating an Author's name\n * should invalidate the cached Book objects so that their new Author information\n * is immediately visible), then you should specify these relations in your models\n * using the `__dependents__` key.\n *\n * NOTE: The values in `__dependents__` can be either classes or strings, but the\n * string should be of the same form as the class name `(Author == 'Author' != 'author')`.\n *\n *      class Book extends Model {\n *          static __dependents__ = [Author];\n *      }\n *\n * If your API contains cases where updating either an Author, or a Book should\n * invalidate the other, then you must specify the dependents in both models.\n */\nexport class BaseModel {\n\n    // Automatically register the given class to the persistence service.\n    static get ps() {\n        return new ModelToken(this);\n    }\n\n    constructor() {\n        // Automatically register the given object to the persistence service.\n        this.ps = new InstanceToken(this.constructor, this);\n    }\n\n    static getDependents() {\n        return [\n            this.name,\n            ...(this.__dependents__ || []),\n        ];\n    }\n\n    /* Model Mapping Methods */\n\n\n    /**\n     * An optional callback, useful for performing any transformations on the\n     * serialized data before it is sent to the API client. This method is invoked\n     * after the instance has exported its data, and after it is cleaned, but\n     * before it is sent to the API client and the schema.\n     *\n     * Note: The return values from this method must match the fields in the\n     * schema, or the schema will throw an error.\n     *\n     * This method is useful if a subclass contains nested data, but the server\n     * is expecting a simple UUID for association.\n     *\n     * Example\n     * -------\n     *      // Our data model\n     *      Book = {\n     *          author: {\n     *              name: \"\",\n     *              authorId: \"1234.434\"\n     *          }\n     *      }\n     *\n     *      // What the schema expects\n     *      Book = {\n     *          author: \"1234.434\"\n     *      }\n     *\n     *      class Book extends Model {\n     *          toSchemaValues = (values) => {\n     *              return { ...values, authorId: values.author.authorId }\n     *          }\n     *      }\n     *\n     */\n    toSchemaValues = (values) => {\n        return values;\n    };\n\n    /**\n     * An optional callback, useful for performing any transformations on the\n     * recieved data before it is sent to the model instance to be imported.\n     * This method is invoked after the new instance is created, and the API\n     * response is received, but before it is sent to the API client and the schema.\n     *\n     * This method is useful if the server sends nested data, but the data model\n     * is expecting a simple UUID for association.\n     *\n     * Example\n     * -------\n     *      // API response\n     *      Book = {\n     *          author: {\n     *              name: \"\",\n     *              authorId: \"1234.434\"\n     *          }\n     *      }\n     *\n     *      // What the Models require\n     *      Book = {\n     *          author: \"1234.434\"\n     *      }\n     *\n     *      class Book extends Model {\n     *          fromSchemaValues = (values) => {\n     *              return { ...values, authorId: values.author.authorId }\n     *          }\n     *      }\n     *\n     */\n    fromSchemaValues = (schemaValues) => {\n        return schemaValues;\n    };\n\n    /**\n     * Given a set of values exported from the given model instance, clean\n     * the fields and do any preparation before handing off the data to the\n     * Hypnos API client.\n     *\n     * By default this method removes and fields in the values that are not\n     * listed in the schema fields for the action that the user is trying to take.\n     *\n     * Subclasses can override this method to provide custom clean behavior.\n     */\n    clean = (keys, values) => {\n        // Get the link to the given action in the schema.\n        const path = keys.join('.');\n        const link = get(schema.content, path, null);\n        if (!link) {\n            throw new Error(`Field ${keys.join(' ')} on type ${this.constructor.name} does not exit.`);\n        }\n\n        // Get the names for the fields in the given schema action.\n        const fieldNames = link.fields.map(({name}) => (name));\n\n        // Omit all of the fields that are not required in the schema for the\n        // action that the user specified.\n        return pick(values, fieldNames);\n    };\n\n    importValues = (values) => {\n        throw new Error(`Model: \"${this.constructor.name}\" must override importValues.`);\n    }\n\n    exportValues = () => {\n        throw new Error(`Model: \"${this.constructor.name}\" must override exportValues.`);\n    };\n}\n",
    "static": true,
    "longname": "/Users/ifoundit/Projects/adventurers_codex/hypnos/src/models/base.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 72,
    "kind": "class",
    "name": "BaseModel",
    "memberof": "src/models/base.js",
    "static": true,
    "longname": "src/models/base.js~BaseModel",
    "access": "public",
    "export": true,
    "importPath": "hypnos/src/models/base.js",
    "importStyle": "{BaseModel}",
    "description": "This class is the base definition of all ES6 style model objects.\n\nModels extending this class will gain the following benefits:\n- Automatic Persistence Service Token registration.\n- Automatic mapping via FetchResponses and mapped queries.\n\nThis model provides no default implementation of serialization or\ndeserialization. Subclasses must implement this feature for their respective\nuse-cases. This framework provides a few default implementations of usable\nmodel classes like: Model and KOModel.\n\n## Mapping Models to the API Schema\n\nOnce you have an API schema you'll need to specify how your model classes\nmap to the schema definition. You do this by specifying the path in the\nmodel's `__skeys__` static attribute.\n\n     class Book extends Model {\n         static __skeys__ = ['resources', 'books'];\n     }\n\n## Specifying Dependents\n\nHypnos automatically takes care of caching and re-serving cached responses for\nidentical queries. If your API has situations where model data is altered by\nchanges to other referenced models in your API (i.e. if updating an Author's name\nshould invalidate the cached Book objects so that their new Author information\nis immediately visible), then you should specify these relations in your models\nusing the `__dependents__` key.\n\nNOTE: The values in `__dependents__` can be either classes or strings, but the\nstring should be of the same form as the class name `(Author == 'Author' != 'author')`.\n\n     class Book extends Model {\n         static __dependents__ = [Author];\n     }\n\nIf your API contains cases where updating either an Author, or a Book should\ninvalidate the other, then you must specify the dependents in both models.",
    "lineNumber": 48,
    "interface": false
  },
  {
    "__docId__": 73,
    "kind": "get",
    "name": "ps",
    "memberof": "src/models/base.js~BaseModel",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/models/base.js~BaseModel.ps",
    "access": "public",
    "description": null,
    "lineNumber": 51,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 74,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/models/base.js~BaseModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/models/base.js~BaseModel#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 55,
    "undocument": true
  },
  {
    "__docId__": 75,
    "kind": "member",
    "name": "ps",
    "memberof": "src/models/base.js~BaseModel",
    "static": false,
    "longname": "src/models/base.js~BaseModel#ps",
    "access": "public",
    "description": null,
    "lineNumber": 57,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 76,
    "kind": "method",
    "name": "getDependents",
    "memberof": "src/models/base.js~BaseModel",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/models/base.js~BaseModel.getDependents",
    "access": "public",
    "description": null,
    "lineNumber": 60,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "undefined[]"
      ]
    }
  },
  {
    "__docId__": 77,
    "kind": "member",
    "name": "toSchemaValues",
    "memberof": "src/models/base.js~BaseModel",
    "static": false,
    "longname": "src/models/base.js~BaseModel#toSchemaValues",
    "access": "public",
    "description": "An optional callback, useful for performing any transformations on the\nserialized data before it is sent to the API client. This method is invoked\nafter the instance has exported its data, and after it is cleaned, but\nbefore it is sent to the API client and the schema.\n\nNote: The return values from this method must match the fields in the\nschema, or the schema will throw an error.\n\nThis method is useful if a subclass contains nested data, but the server\nis expecting a simple UUID for association.\n\nExample\n-------\n     // Our data model\n     Book = {\n         author: {\n             name: \"\",\n             authorId: \"1234.434\"\n         }\n     }\n\n     // What the schema expects\n     Book = {\n         author: \"1234.434\"\n     }\n\n     class Book extends Model {\n         toSchemaValues = (values) => {\n             return { ...values, authorId: values.author.authorId }\n         }\n     }",
    "lineNumber": 104,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 78,
    "kind": "member",
    "name": "fromSchemaValues",
    "memberof": "src/models/base.js~BaseModel",
    "static": false,
    "longname": "src/models/base.js~BaseModel#fromSchemaValues",
    "access": "public",
    "description": "An optional callback, useful for performing any transformations on the\nrecieved data before it is sent to the model instance to be imported.\nThis method is invoked after the new instance is created, and the API\nresponse is received, but before it is sent to the API client and the schema.\n\nThis method is useful if the server sends nested data, but the data model\nis expecting a simple UUID for association.\n\nExample\n-------\n     // API response\n     Book = {\n         author: {\n             name: \"\",\n             authorId: \"1234.434\"\n         }\n     }\n\n     // What the Models require\n     Book = {\n         author: \"1234.434\"\n     }\n\n     class Book extends Model {\n         fromSchemaValues = (values) => {\n             return { ...values, authorId: values.author.authorId }\n         }\n     }",
    "lineNumber": 139,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 79,
    "kind": "member",
    "name": "clean",
    "memberof": "src/models/base.js~BaseModel",
    "static": false,
    "longname": "src/models/base.js~BaseModel#clean",
    "access": "public",
    "description": "Given a set of values exported from the given model instance, clean\nthe fields and do any preparation before handing off the data to the\nHypnos API client.\n\nBy default this method removes and fields in the values that are not\nlisted in the schema fields for the action that the user is trying to take.\n\nSubclasses can override this method to provide custom clean behavior.",
    "lineNumber": 153,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 80,
    "kind": "member",
    "name": "importValues",
    "memberof": "src/models/base.js~BaseModel",
    "static": false,
    "longname": "src/models/base.js~BaseModel#importValues",
    "access": "public",
    "description": null,
    "lineNumber": 169,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 81,
    "kind": "member",
    "name": "exportValues",
    "memberof": "src/models/base.js~BaseModel",
    "static": false,
    "longname": "src/models/base.js~BaseModel#exportValues",
    "access": "public",
    "description": null,
    "lineNumber": 173,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 82,
    "kind": "file",
    "name": "src/models/ko.js",
    "content": "import { BaseModel } from './base';\nimport ko from 'knockout';\n\n/**\n * A subclass of the Base `Model` class which adds serialization and\n * deserialization via Knockout's built-in mapping functionality.\n */\nexport class KOModel extends BaseModel {\n\n    /**\n     * Check to see if the subclasses provide a mapping, if they do\n     * not, then raise an exception.\n     */\n    get _mapping() {\n        const mapping = this.constructor.mapping;\n        if (!mapping) {\n            throw new Error(`Model: \"${this.constructor.name}\" does not provide a mapping.`);\n        }\n\n        return mapping;\n    }\n\n    /**\n     * A default implementation of object deserialization using Knockout autoignore\n     * mapping. For custom mapping, subclasses can override this method.\n     */\n    importValues = (values) => {\n        ko.mapping.fromJS(values, this._mapping, this);\n    }\n\n    /**\n     * A default implementation of object serialization using Knockout autoignore\n     * mapping. For custom mapping, subclasses can override this method.\n     */\n    exportValues = () => {\n        return ko.mapping.toJS(this, this._mapping);\n    };\n}\n",
    "static": true,
    "longname": "/Users/ifoundit/Projects/adventurers_codex/hypnos/src/models/ko.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 83,
    "kind": "class",
    "name": "KOModel",
    "memberof": "src/models/ko.js",
    "static": true,
    "longname": "src/models/ko.js~KOModel",
    "access": "public",
    "export": true,
    "importPath": "hypnos/src/models/ko.js",
    "importStyle": "{KOModel}",
    "description": "A subclass of the Base `Model` class which adds serialization and\ndeserialization via Knockout's built-in mapping functionality.",
    "lineNumber": 8,
    "interface": false,
    "extends": [
      "src/models/base.js~BaseModel"
    ]
  },
  {
    "__docId__": 84,
    "kind": "get",
    "name": "_mapping",
    "memberof": "src/models/ko.js~KOModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/models/ko.js~KOModel#_mapping",
    "access": "private",
    "description": "Check to see if the subclasses provide a mapping, if they do\nnot, then raise an exception.",
    "lineNumber": 14,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 85,
    "kind": "member",
    "name": "importValues",
    "memberof": "src/models/ko.js~KOModel",
    "static": false,
    "longname": "src/models/ko.js~KOModel#importValues",
    "access": "public",
    "description": "A default implementation of object deserialization using Knockout autoignore\nmapping. For custom mapping, subclasses can override this method.",
    "lineNumber": 27,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 86,
    "kind": "member",
    "name": "exportValues",
    "memberof": "src/models/ko.js~KOModel",
    "static": false,
    "longname": "src/models/ko.js~KOModel#exportValues",
    "access": "public",
    "description": "A default implementation of object serialization using Knockout autoignore\nmapping. For custom mapping, subclasses can override this method.",
    "lineNumber": 35,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 87,
    "kind": "file",
    "name": "src/models/model.js",
    "content": "import { BaseModel } from './base';\n\n/**\n * A subclass of the Base `Model` class which provides serialization and\n * deserialization via a whitelist of fields to serialize/deserialize.\n */\nexport class Model extends BaseModel {\n\n    static FIELDS = [];\n\n    importValues = (values) => {\n        this.constructor.FIELDS.forEach(field => {\n            this[field] = values[field];\n        });\n    };\n\n    exportValues = () => {\n        let values = {};\n        this.constructor.FIELDS.forEach(field => {\n            values[field] = this[field];\n        });\n        return values;\n    };\n}\n",
    "static": true,
    "longname": "/Users/ifoundit/Projects/adventurers_codex/hypnos/src/models/model.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 88,
    "kind": "class",
    "name": "Model",
    "memberof": "src/models/model.js",
    "static": true,
    "longname": "src/models/model.js~Model",
    "access": "public",
    "export": true,
    "importPath": "hypnos/src/models/model.js",
    "importStyle": "{Model}",
    "description": "A subclass of the Base `Model` class which provides serialization and\ndeserialization via a whitelist of fields to serialize/deserialize.",
    "lineNumber": 7,
    "interface": false,
    "extends": [
      "src/models/base.js~BaseModel"
    ]
  },
  {
    "__docId__": 89,
    "kind": "member",
    "name": "FIELDS",
    "memberof": "src/models/model.js~Model",
    "static": true,
    "longname": "src/models/model.js~Model.FIELDS",
    "access": "public",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 90,
    "kind": "member",
    "name": "importValues",
    "memberof": "src/models/model.js~Model",
    "static": false,
    "longname": "src/models/model.js~Model#importValues",
    "access": "public",
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 91,
    "kind": "member",
    "name": "[field]",
    "memberof": "src/models/model.js~Model",
    "longname": "src/models/model.js~Model#[field]",
    "access": "public",
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 92,
    "kind": "member",
    "name": "exportValues",
    "memberof": "src/models/model.js~Model",
    "static": false,
    "longname": "src/models/model.js~Model#exportValues",
    "access": "public",
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 93,
    "kind": "file",
    "name": "src/response.js",
    "content": "import uuid from 'uuid';\n\n\n/**\n * An APIResponse is a convenience wrapper around the data received when doing\n * a mapped query to the API.\n *\n * If a model instance is provided, the APIResponse will map the response data\n * to the model (see Model Serialization for more information). The APIResponse\n * also remembers the original response data for reference.\n *\n * Accessing the Response Objects\n * ------------------------------\n * Depending on the type of query, responses are mapped to either the `object`\n * or `objects` (note the plural) property on the APIResponse. In the case of\n * a query that will return multiple objects (i.e. when the `many` flag is set)\n * the resulting objects will be mapped and set to the `objects` property.\n * Otherwise single objects are always mapped to the `object` property.\n *\n * Navigating Paginated Responses\n * ------------------------------\n * A APIResponse provides an easy way to navigate through paginated results.\n * When retrieving a result set that is paginated (i.e. with\n * `Persistence.service.list()`), APIResponse provides two convenience methods:\n *\n * - getNextPage: Will fetch the next page in a result set if there is one.\n * - getPreviousPage: Will fetch the previous page in a result set if there is one.\n *\n * Using these two methods you can navigate the results of the query you made\n * originally. Note that you cannot change the parameters or modify the state\n * of the query once it is made. To sort and filter based on different critera,\n * you'll need to make a new query from the Persistence.service.\n *\n */\nclass APIResponse {\n\n    constructor({ data, keys, params, model=null, many=false, fromCache=false }) {\n        this.id = uuid.v4().toString();\n        this.fetchParams = params;\n        this.fetchKeys = keys;\n        this.data = data;\n        this.many = many;\n        this.model = model;\n        this.fromCache = fromCache;\n\n        // Map response to model object(s).\n        if (model && data) {\n            if (many && data.results) {\n                this.objects = data.results.map(result => {\n                    const instance = new model();\n                    const schemaValues = instance.fromSchemaValues(result);\n                    instance.importValues(schemaValues);\n                    return instance;\n                });\n            } else {\n                const instance = new model();\n                const schemaValues = instance.fromSchemaValues(data);\n                instance.importValues(schemaValues);\n                this.object = instance;\n            }\n        }\n    }\n\n    /**\n     * Returns whether or not the given fetch response has a next page.\n     */\n    hasNextPage = () => (\n        this.many && this.data.next\n    );\n\n    /**\n     * Returns whether or not the given fetch response has a previous page.\n     */\n    hasPreviousPage = () => (\n        this.many && this.data.previous\n    );\n\n    /**\n     * Fetch the next page of results in a paginated result set.\n     *\n     * This method returns a promise to the APIResponse of the next page.\n     *\n     * WARNING: This method will throw an error when attempting to fetch a next\n     * page for a single object result set or if there is no next page.\n     * To avoid this, check if the APIResponse `hasNextPage` before calling.\n     */\n    getNextPage = () => (new Promise((resolve) => {\n        if (!this.many || !this.hasNextPage()) {\n            throw new Error(`Given APIResponse: ${this.id} does not have a next value.`);\n        }\n\n        const nextPageFetchParams = { ...this.fetchParams, page: this._getNextPageNumber() };\n        return Persistence.service.action(\n            this.fetchKeys,\n            nextPageFetchParams,\n            false,\n            this.model,\n            this.many\n        ).then(resolve);\n    }));\n\n    /**\n     * Fetch the previous page of results in a paginated result set.\n     *\n     * This method returns a promise to the APIResponse of the previous page.\n     *\n     * WARNING: This method will throw an error when attempting to fetch a previous\n     * page for a single object result set or if there is no previous page.\n     * To avoid this, check if the APIResponse `hasPreviousPage` before calling.\n     */\n    getPreviousPage = () => (new Promise((resolve) => {\n        if (!this.many || !this.hasPreviousPage()) {\n            throw new Error(`Given APIResponse: ${this.id} does not have a previous value.`);\n        }\n        const previousPageFetchParams = { ...this.fetchParams, page: this._getPreviousPageNumber() };\n        return Persistence.service.action(\n            this.fetchKeys,\n            previousPageFetchParams,\n            false,\n            this.model,\n            this.many\n        ).then(resolve);\n    }));\n\n    /* Private Methods */\n\n    _getCurrentPage = () => (\n        this.fetchParams.page ? this.fetchParams.page : 1\n    );\n\n    _getNextPageNumber = () => (\n        this._getCurrentPage() + 1\n    );\n\n    _getPreviousPageNumber = () => (\n        this._getCurrentPage() - 1\n    );\n}\n\n\nexport default APIResponse;\n",
    "static": true,
    "longname": "/Users/ifoundit/Projects/adventurers_codex/hypnos/src/response.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 94,
    "kind": "class",
    "name": "APIResponse",
    "memberof": "src/response.js",
    "static": true,
    "longname": "src/response.js~APIResponse",
    "access": "public",
    "export": true,
    "importPath": "hypnos/src/response.js",
    "importStyle": "APIResponse",
    "description": "An APIResponse is a convenience wrapper around the data received when doing\na mapped query to the API.\n\nIf a model instance is provided, the APIResponse will map the response data\nto the model (see Model Serialization for more information). The APIResponse\nalso remembers the original response data for reference.\n\nAccessing the Response Objects\n------------------------------\nDepending on the type of query, responses are mapped to either the `object`\nor `objects` (note the plural) property on the APIResponse. In the case of\na query that will return multiple objects (i.e. when the `many` flag is set)\nthe resulting objects will be mapped and set to the `objects` property.\nOtherwise single objects are always mapped to the `object` property.\n\nNavigating Paginated Responses\n------------------------------\nA APIResponse provides an easy way to navigate through paginated results.\nWhen retrieving a result set that is paginated (i.e. with\n`Persistence.service.list()`), APIResponse provides two convenience methods:\n\n- getNextPage: Will fetch the next page in a result set if there is one.\n- getPreviousPage: Will fetch the previous page in a result set if there is one.\n\nUsing these two methods you can navigate the results of the query you made\noriginally. Note that you cannot change the parameters or modify the state\nof the query once it is made. To sort and filter based on different critera,\nyou'll need to make a new query from the Persistence.service.",
    "lineNumber": 35,
    "interface": false
  },
  {
    "__docId__": 95,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/response.js~APIResponse",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/response.js~APIResponse#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 37,
    "undocument": true
  },
  {
    "__docId__": 96,
    "kind": "member",
    "name": "id",
    "memberof": "src/response.js~APIResponse",
    "static": false,
    "longname": "src/response.js~APIResponse#id",
    "access": "public",
    "description": null,
    "lineNumber": 38,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 97,
    "kind": "member",
    "name": "fetchParams",
    "memberof": "src/response.js~APIResponse",
    "static": false,
    "longname": "src/response.js~APIResponse#fetchParams",
    "access": "public",
    "description": null,
    "lineNumber": 39,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 98,
    "kind": "member",
    "name": "fetchKeys",
    "memberof": "src/response.js~APIResponse",
    "static": false,
    "longname": "src/response.js~APIResponse#fetchKeys",
    "access": "public",
    "description": null,
    "lineNumber": 40,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 99,
    "kind": "member",
    "name": "data",
    "memberof": "src/response.js~APIResponse",
    "static": false,
    "longname": "src/response.js~APIResponse#data",
    "access": "public",
    "description": null,
    "lineNumber": 41,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 100,
    "kind": "member",
    "name": "many",
    "memberof": "src/response.js~APIResponse",
    "static": false,
    "longname": "src/response.js~APIResponse#many",
    "access": "public",
    "description": null,
    "lineNumber": 42,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 101,
    "kind": "member",
    "name": "model",
    "memberof": "src/response.js~APIResponse",
    "static": false,
    "longname": "src/response.js~APIResponse#model",
    "access": "public",
    "description": null,
    "lineNumber": 43,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 102,
    "kind": "member",
    "name": "fromCache",
    "memberof": "src/response.js~APIResponse",
    "static": false,
    "longname": "src/response.js~APIResponse#fromCache",
    "access": "public",
    "description": null,
    "lineNumber": 44,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 103,
    "kind": "member",
    "name": "objects",
    "memberof": "src/response.js~APIResponse",
    "static": false,
    "longname": "src/response.js~APIResponse#objects",
    "access": "public",
    "description": null,
    "lineNumber": 49,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 104,
    "kind": "member",
    "name": "object",
    "memberof": "src/response.js~APIResponse",
    "static": false,
    "longname": "src/response.js~APIResponse#object",
    "access": "public",
    "description": null,
    "lineNumber": 59,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 105,
    "kind": "member",
    "name": "hasNextPage",
    "memberof": "src/response.js~APIResponse",
    "static": false,
    "longname": "src/response.js~APIResponse#hasNextPage",
    "access": "public",
    "description": "Returns whether or not the given fetch response has a next page.",
    "lineNumber": 67,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 106,
    "kind": "member",
    "name": "hasPreviousPage",
    "memberof": "src/response.js~APIResponse",
    "static": false,
    "longname": "src/response.js~APIResponse#hasPreviousPage",
    "access": "public",
    "description": "Returns whether or not the given fetch response has a previous page.",
    "lineNumber": 74,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 107,
    "kind": "member",
    "name": "getNextPage",
    "memberof": "src/response.js~APIResponse",
    "static": false,
    "longname": "src/response.js~APIResponse#getNextPage",
    "access": "public",
    "description": "Fetch the next page of results in a paginated result set.\n\nThis method returns a promise to the APIResponse of the next page.\n\nWARNING: This method will throw an error when attempting to fetch a next\npage for a single object result set or if there is no next page.\nTo avoid this, check if the APIResponse `hasNextPage` before calling.",
    "lineNumber": 87,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 108,
    "kind": "member",
    "name": "getPreviousPage",
    "memberof": "src/response.js~APIResponse",
    "static": false,
    "longname": "src/response.js~APIResponse#getPreviousPage",
    "access": "public",
    "description": "Fetch the previous page of results in a paginated result set.\n\nThis method returns a promise to the APIResponse of the previous page.\n\nWARNING: This method will throw an error when attempting to fetch a previous\npage for a single object result set or if there is no previous page.\nTo avoid this, check if the APIResponse `hasPreviousPage` before calling.",
    "lineNumber": 111,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 109,
    "kind": "member",
    "name": "_getCurrentPage",
    "memberof": "src/response.js~APIResponse",
    "static": false,
    "longname": "src/response.js~APIResponse#_getCurrentPage",
    "access": "private",
    "description": null,
    "lineNumber": 127,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 110,
    "kind": "member",
    "name": "_getNextPageNumber",
    "memberof": "src/response.js~APIResponse",
    "static": false,
    "longname": "src/response.js~APIResponse#_getNextPageNumber",
    "access": "private",
    "description": null,
    "lineNumber": 131,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 111,
    "kind": "member",
    "name": "_getPreviousPageNumber",
    "memberof": "src/response.js~APIResponse",
    "static": false,
    "longname": "src/response.js~APIResponse#_getPreviousPageNumber",
    "access": "private",
    "description": null,
    "lineNumber": 135,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 112,
    "kind": "file",
    "name": "src/tokens.js",
    "content": "import { Hypnos } from './hypnos';\n\n/**\n * An Instance Token provides quick access to the Hypnos\n * client methods through a model instance. You can use an\n * object's Instance Token to easily and clearly perform queries and updates to the\n * backing API using syntax bound to the Instance itself, rather than using\n * the normal Hypnos API.\n *\n * Example\n * -------\n *\n * Let's say you want to search for all books in your collection. Using the\n * normal Hypnos API you could perform a query for all books like this:\n *\n *      const { object: book } = await Hypnos.client.update(Book, {\n *          id: '123',\n *          title: 'A new title'\n *      });\n *      // Do stuff with the updated book...\n *\n * But using the InstanceToken API on a given Model would allow the\n * following shortcut syntax.\n *\n *      const { object: book } = await Book.ps.read({ id: '1234' });\n *      book.title = 'A new title';\n *      book.ps.save();\n *\n * For more information about what queries are available with this API, please\n * see the associated documentation below.\n */\nexport class InstanceToken {\n\n    constructor(model, instance) {\n        this.model = model;\n        this.instance = instance;\n        this.client = Hypnos.client;\n    }\n\n    /**\n     * This method allows the creation of model object data directly to the\n     * remote API.\n     *\n     * WARNING: Once you've used the original \"template\" instance to create an\n     * object, you should not continue using that object in your code. Always\n     * use the instance returned from the response since it has all of the required\n     * data from the API to perform the rest of the expected functionality.\n     *\n     * Example\n     * -------\n     *\n     * Let's assume that you have a model you've created locally, you've\n     * filed in the values, and now you want to tell your API to create that\n     * new object.\n     *\n     *      const instance = new MyModel();\n     *      // ...fill in the values...\n     *      instance.ps.create().then(response => {\n     *          const persistedInstance = response.object;\n     *      });\n     */\n    create = async () => {\n        const keys = [...this.model.__skeys__, 'create'];\n        const params = this.instance.exportValues();\n        const cleanedParams = this.instance.clean(keys, params);\n        const schemaValues = this.instance.toSchemaValues(cleanedParams);\n        return await this.client.action({\n            keys,\n            params: schemaValues,\n            raw: false,\n            model: this.model,\n            many: false,\n        });\n    };\n\n    /**\n     * Refresh the data for the given object from the remote store.\n     */\n    refresh = async () => {\n        const keys = [...this.model.__skeys__, 'read'];\n        const params = this.instance.exportValues();\n        const cleanedParams = this.instance.clean(keys, params);\n        const schemaValues = this.instance.toSchemaValues(cleanedParams);\n        return await this.client.action({\n            keys,\n            params: schemaValues,\n            raw: false,\n            model: this.model,\n            many: false,\n        });\n    };\n\n    /**\n     * Persist the object's data to the remote store. This only works for\n     * existing objects.\n     *\n     * If a list of fields is provided, then only update those fields.\n     */\n    save = async (fields=null, raw=false) => {\n        let method = 'update';\n        const params = this.instance.exportValues();\n\n        // Trim out unneeded fields if `fields` is provided and\n        // set the active method to use partial_update.\n        if (fields && fields.length > 0) {\n            method = 'partialUpdate';\n            Object.keys(params).forEach(key => {\n                if (fields.indexOf(key) == -1) {\n                    delete params[key];\n                }\n            });\n        }\n\n        const keys = [...this.model.__skeys__, method];\n        const cleanedParams = this.instance.clean(keys, params);\n        const schemaValues = this.instance.toSchemaValues(cleanedParams);\n        return await this.client.action({\n            keys,\n            params: schemaValues,\n            raw,\n            model: this.model,\n            many: false,\n        });\n    };\n\n    /**\n     * Tell the remote store to destroy the current object.\n     *\n     * WARNING: This does not remove the object from memory, only from\n     * the remote store.\n     */\n    delete = async () => {\n        const keys = [...this.model.__skeys__, 'delete'];\n        const params = this.instance.exportValues();\n        const cleanedParams = this.instance.clean(keys, params);\n        const schemaValues = this.instance.toSchemaValues(cleanedParams);\n        return await this.client.action({\n            keys,\n            params: schemaValues,\n            raw: true,\n            model: this.model,\n            many: false,\n        });\n    };\n}\n\n\n/**\n * A ModelToken, like an InstanceToken provides quick access to the Hypnos\n * client methods without an active model instance to use. You can use an\n * object's Model Token to easily and clearly perform queries and updates to the\n * backing API using syntax bound to the Model class itself, rather than using\n * the normal Hypnos API.\n *\n * Example\n * -------\n *\n * Let's say you want to search for all books in your collection. Using the\n * normal Hypnos API you could perform a query for all books like this:\n *\n *      const response = await Hypnos.client.list(Book);\n *      const books = response.objects;\n *      // Do stuff with books...\n *\n * But implementing the ModelToken API on a given Model would allow the\n * following shortcut syntax.\n *\n *      const response = await Book.ps.list();\n *      const books = response.objects;\n *      // Do stuff with books...\n *\n * For more information about what queries are available with this API, please\n * see the associated documentation below.\n *\n * For more information about performing queries on mapped Model instances\n * (i.e. your new book instances) please refer to the InstanceToken documentation.\n */\nexport class ModelToken {\n\n    constructor(model) {\n        this.model = model;\n        this.client = Hypnos.client;\n    }\n\n    /**\n     * Given a model type and an optional set of parameters, perform a list query\n     * against the backing API and return a promise of results in the form of a\n     * FetchResponse (see FetchResponse for more information).\n     *\n     * Example\n     * -------\n     *\n     *     Book.ps.list().then(response => {\n     *         const books = response.objects;\n     *         // Do stuff with books...\n     *     });\n     */\n    list = async (params={}, raw=false, useCache=true, flushDepsCache=false) => {\n        const keys = [...this.model.__skeys__, 'list'];\n        return await this.client.action({\n            keys,\n            params,\n            raw,\n            model: this.model,\n            many: true,\n            useCache,\n            flushDepsCache,\n        });\n    };\n\n    /**\n     * Given a model type and an optional set of parameters, perform a retrieve\n     * query against the backing API and return a promise of results in the\n     * form of a FetchResponse (see FetchResponse for more information).\n     *\n     * Example\n     * -------\n     *\n     *     Book.ps.read({ id: '1234' }).then(response => {\n     *         const book = response.object;\n     *         // Do stuff with your book...\n     *     });\n     */\n    read = async (params={}, raw=false, useCache=true, flushDepsCache=false) => {\n        const keys = [...this.model.__skeys__, 'read'];\n        return await this.client.action({\n            keys,\n            params,\n            raw,\n            model: this.model,\n            many: false,\n            useCache,\n            flushDepsCache,\n        });\n    };\n\n    /**\n     * Given a model type and an optional set of parameters, perform a create\n     * against the backing API and return a promise of results in the\n     * form of a FetchResponse (see FetchResponse for more information).\n     *\n     * Example\n     * -------\n     *\n     *     const data = { title: 'An Adventure', author: 'John Smith' };\n     *     Book.ps.create(data).then(response => {\n     *         const book = response.object;\n     *         // Do stuff with your new book...\n     *     });\n     */\n    create = async (params={}, raw=false) => {\n        const keys = [...this.model.__skeys__, 'create'];\n        return await this.client.action({\n            keys,\n            params,\n            raw,\n            model: this.model,\n            many: false,\n        });\n    };\n\n    /**\n     * Given a model type and an optional set of parameters, perform an update\n     * against the backing API and return a promise of results in the\n     * form of a FetchResponse (see FetchResponse for more information).\n     *\n     * Example\n     * -------\n     *\n     *     const data = { id: '1234', title: 'An Adventure II', author: 'John Smith' };\n     *     Book.ps.update(data).then(response => {\n     *         const book = response.object;\n     *         // Do stuff with your updated book...\n     *     });\n     */\n    update = async (params={}, raw=false) => {\n        const keys = [...this.model.__skeys__, 'update'];\n        return await this.client.action({\n            keys,\n            params,\n            raw,\n            model: this.model,\n            many: false,\n        });\n    };\n\n    /**\n     * Given a model type and an optional set of parameters, perform a destroy\n     * against the backing API and return a promise of results in the\n     * form of a FetchResponse (see FetchResponse for more information).\n     *\n     * Example\n     * -------\n     *\n     *     Book.ps.delete({ id: '1234' });\n     */\n    delete = async (params={}, raw=false) => {\n        const keys = [...this.model.__skeys__, 'delete'];\n        return await this.client.action({\n            keys,\n            params,\n            raw,\n            model: this.model,\n            many: false,\n        });\n    };\n}\n",
    "static": true,
    "longname": "/Users/ifoundit/Projects/adventurers_codex/hypnos/src/tokens.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 113,
    "kind": "class",
    "name": "InstanceToken",
    "memberof": "src/tokens.js",
    "static": true,
    "longname": "src/tokens.js~InstanceToken",
    "access": "public",
    "export": true,
    "importPath": "hypnos/src/tokens.js",
    "importStyle": "{InstanceToken}",
    "description": "An Instance Token provides quick access to the Hypnos\nclient methods through a model instance. You can use an\nobject's Instance Token to easily and clearly perform queries and updates to the\nbacking API using syntax bound to the Instance itself, rather than using\nthe normal Hypnos API.\n\nExample\n-------\n\nLet's say you want to search for all books in your collection. Using the\nnormal Hypnos API you could perform a query for all books like this:\n\n     const { object: book } = await Hypnos.client.update(Book, {\n         id: '123',\n         title: 'A new title'\n     });\n     // Do stuff with the updated book...\n\nBut using the InstanceToken API on a given Model would allow the\nfollowing shortcut syntax.\n\n     const { object: book } = await Book.ps.read({ id: '1234' });\n     book.title = 'A new title';\n     book.ps.save();\n\nFor more information about what queries are available with this API, please\nsee the associated documentation below.",
    "lineNumber": 32,
    "interface": false
  },
  {
    "__docId__": 114,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/tokens.js~InstanceToken",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/tokens.js~InstanceToken#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 34,
    "undocument": true
  },
  {
    "__docId__": 115,
    "kind": "member",
    "name": "model",
    "memberof": "src/tokens.js~InstanceToken",
    "static": false,
    "longname": "src/tokens.js~InstanceToken#model",
    "access": "public",
    "description": null,
    "lineNumber": 35,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 116,
    "kind": "member",
    "name": "instance",
    "memberof": "src/tokens.js~InstanceToken",
    "static": false,
    "longname": "src/tokens.js~InstanceToken#instance",
    "access": "public",
    "description": null,
    "lineNumber": 36,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 117,
    "kind": "member",
    "name": "client",
    "memberof": "src/tokens.js~InstanceToken",
    "static": false,
    "longname": "src/tokens.js~InstanceToken#client",
    "access": "public",
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 118,
    "kind": "member",
    "name": "create",
    "memberof": "src/tokens.js~InstanceToken",
    "static": false,
    "longname": "src/tokens.js~InstanceToken#create",
    "access": "public",
    "description": "This method allows the creation of model object data directly to the\nremote API.\n\nWARNING: Once you've used the original \"template\" instance to create an\nobject, you should not continue using that object in your code. Always\nuse the instance returned from the response since it has all of the required\ndata from the API to perform the rest of the expected functionality.\n\nExample\n-------\n\nLet's assume that you have a model you've created locally, you've\nfiled in the values, and now you want to tell your API to create that\nnew object.\n\n     const instance = new MyModel();\n     // ...fill in the values...\n     instance.ps.create().then(response => {\n         const persistedInstance = response.object;\n     });",
    "lineNumber": 62,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 119,
    "kind": "member",
    "name": "refresh",
    "memberof": "src/tokens.js~InstanceToken",
    "static": false,
    "longname": "src/tokens.js~InstanceToken#refresh",
    "access": "public",
    "description": "Refresh the data for the given object from the remote store.",
    "lineNumber": 79,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 120,
    "kind": "member",
    "name": "save",
    "memberof": "src/tokens.js~InstanceToken",
    "static": false,
    "longname": "src/tokens.js~InstanceToken#save",
    "access": "public",
    "description": "Persist the object's data to the remote store. This only works for\nexisting objects.\n\nIf a list of fields is provided, then only update those fields.",
    "lineNumber": 99,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 121,
    "kind": "member",
    "name": "delete",
    "memberof": "src/tokens.js~InstanceToken",
    "static": false,
    "longname": "src/tokens.js~InstanceToken#delete",
    "access": "public",
    "description": "Tell the remote store to destroy the current object.\n\nWARNING: This does not remove the object from memory, only from\nthe remote store.",
    "lineNumber": 132,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 122,
    "kind": "class",
    "name": "ModelToken",
    "memberof": "src/tokens.js",
    "static": true,
    "longname": "src/tokens.js~ModelToken",
    "access": "public",
    "export": true,
    "importPath": "hypnos/src/tokens.js",
    "importStyle": "{ModelToken}",
    "description": "A ModelToken, like an InstanceToken provides quick access to the Hypnos\nclient methods without an active model instance to use. You can use an\nobject's Model Token to easily and clearly perform queries and updates to the\nbacking API using syntax bound to the Model class itself, rather than using\nthe normal Hypnos API.\n\nExample\n-------\n\nLet's say you want to search for all books in your collection. Using the\nnormal Hypnos API you could perform a query for all books like this:\n\n     const response = await Hypnos.client.list(Book);\n     const books = response.objects;\n     // Do stuff with books...\n\nBut implementing the ModelToken API on a given Model would allow the\nfollowing shortcut syntax.\n\n     const response = await Book.ps.list();\n     const books = response.objects;\n     // Do stuff with books...\n\nFor more information about what queries are available with this API, please\nsee the associated documentation below.\n\nFor more information about performing queries on mapped Model instances\n(i.e. your new book instances) please refer to the InstanceToken documentation.",
    "lineNumber": 178,
    "interface": false
  },
  {
    "__docId__": 123,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/tokens.js~ModelToken",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/tokens.js~ModelToken#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 180,
    "undocument": true
  },
  {
    "__docId__": 124,
    "kind": "member",
    "name": "model",
    "memberof": "src/tokens.js~ModelToken",
    "static": false,
    "longname": "src/tokens.js~ModelToken#model",
    "access": "public",
    "description": null,
    "lineNumber": 181,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 125,
    "kind": "member",
    "name": "client",
    "memberof": "src/tokens.js~ModelToken",
    "static": false,
    "longname": "src/tokens.js~ModelToken#client",
    "access": "public",
    "description": null,
    "lineNumber": 182,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 126,
    "kind": "member",
    "name": "list",
    "memberof": "src/tokens.js~ModelToken",
    "static": false,
    "longname": "src/tokens.js~ModelToken#list",
    "access": "public",
    "description": "Given a model type and an optional set of parameters, perform a list query\nagainst the backing API and return a promise of results in the form of a\nFetchResponse (see FetchResponse for more information).\n\nExample\n-------\n\n    Book.ps.list().then(response => {\n        const books = response.objects;\n        // Do stuff with books...\n    });",
    "lineNumber": 198,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 127,
    "kind": "member",
    "name": "read",
    "memberof": "src/tokens.js~ModelToken",
    "static": false,
    "longname": "src/tokens.js~ModelToken#read",
    "access": "public",
    "description": "Given a model type and an optional set of parameters, perform a retrieve\nquery against the backing API and return a promise of results in the\nform of a FetchResponse (see FetchResponse for more information).\n\nExample\n-------\n\n    Book.ps.read({ id: '1234' }).then(response => {\n        const book = response.object;\n        // Do stuff with your book...\n    });",
    "lineNumber": 224,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 128,
    "kind": "member",
    "name": "create",
    "memberof": "src/tokens.js~ModelToken",
    "static": false,
    "longname": "src/tokens.js~ModelToken#create",
    "access": "public",
    "description": "Given a model type and an optional set of parameters, perform a create\nagainst the backing API and return a promise of results in the\nform of a FetchResponse (see FetchResponse for more information).\n\nExample\n-------\n\n    const data = { title: 'An Adventure', author: 'John Smith' };\n    Book.ps.create(data).then(response => {\n        const book = response.object;\n        // Do stuff with your new book...\n    });",
    "lineNumber": 251,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 129,
    "kind": "member",
    "name": "update",
    "memberof": "src/tokens.js~ModelToken",
    "static": false,
    "longname": "src/tokens.js~ModelToken#update",
    "access": "public",
    "description": "Given a model type and an optional set of parameters, perform an update\nagainst the backing API and return a promise of results in the\nform of a FetchResponse (see FetchResponse for more information).\n\nExample\n-------\n\n    const data = { id: '1234', title: 'An Adventure II', author: 'John Smith' };\n    Book.ps.update(data).then(response => {\n        const book = response.object;\n        // Do stuff with your updated book...\n    });",
    "lineNumber": 276,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 130,
    "kind": "member",
    "name": "delete",
    "memberof": "src/tokens.js~ModelToken",
    "static": false,
    "longname": "src/tokens.js~ModelToken#delete",
    "access": "public",
    "description": "Given a model type and an optional set of parameters, perform a destroy\nagainst the backing API and return a promise of results in the\nform of a FetchResponse (see FetchResponse for more information).\n\nExample\n-------\n\n    Book.ps.delete({ id: '1234' });",
    "lineNumber": 297,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 131,
    "kind": "file",
    "name": "src/tokens.spec.js",
    "content": "import { Author, Book } from './__mocks__/models';\nimport { Hypnos } from './index';\nimport coreapi from 'coreapi';\nimport { mockedFetch } from './__helpers__/utils';\nimport schema from './__mocks__/schema';\n\nconst defaultConfiguration = {\n    schema,\n    credentials: {},\n    cacheConfig: {},\n};\n\ndescribe('Tokens', () => {\n    beforeEach(() => {\n        Hypnos.flush();\n\n        Hypnos.configuration = { ...defaultConfiguration };\n    });\n\n    describe('Model Tokens', () => {\n        it('should attempt to create a book model', async () => {\n            const bookFixture = {\n                title: 'A Title',\n                author: 'Me',\n                isBestseller: false,\n            };\n\n            const transport = new coreapi.transports.HTTPTransport({\n                fetch: mockedFetch(JSON.stringify({ ...bookFixture }), 'application/json')\n            });\n            Hypnos.client.client = new coreapi.Client({ transports: [transport] });\n\n            const response = await Book.ps.create({ ...bookFixture });\n\n            expect(response.fromCache).toBe(false);\n            expect(response.fetchParams).toEqual(bookFixture);\n            expect(response.many).toEqual(false);\n\n            const book = response.object;\n\n            expect(book.title).toEqual(bookFixture.title);\n            expect(book.author).toEqual(bookFixture.author);\n            expect(book.isBestseller).toEqual(bookFixture.isBestseller);\n        });\n\n        it('should attempt to list all book models -- uncached', async () => {\n            const bookFixtures = [\n                {\n                    title: 'A Title',\n                    author: 'Me',\n                    isBestseller: false,\n                },\n                {\n                    title: 'Another Title',\n                    author: 'You',\n                    isBestseller: true,\n                },\n            ];\n\n            const transport = new coreapi.transports.HTTPTransport({\n                fetch: mockedFetch(JSON.stringify({ results: [...bookFixtures] }), 'application/json')\n            });\n            Hypnos.client.client = new coreapi.Client({ transports: [transport] });\n\n            const response = await Book.ps.list();\n\n            expect(response.fromCache).toBe(false);\n            expect(response.fetchParams).toEqual({});\n            expect(response.many).toEqual(true);\n\n            const books = response.objects;\n\n            expect(books[0].title).toEqual(bookFixtures[0].title);\n            expect(books[0].author).toEqual(bookFixtures[0].author);\n            expect(books[0].isBestseller).toEqual(bookFixtures[0].isBestseller);\n        });\n\n        it('should attempt to retrieve a book model -- uncached', async () => {\n            const bookFixture = {\n                uuid: '12345-123-4352-1234',\n                title: 'A Title',\n                author: 'Me',\n                isBestseller: false,\n            };\n\n            const transport = new coreapi.transports.HTTPTransport({\n                fetch: mockedFetch(JSON.stringify({ ...bookFixture }), 'application/json')\n            });\n            Hypnos.client.client = new coreapi.Client({ transports: [transport] });\n\n            const response = await Book.ps.read({ uuid: bookFixture.uuid });\n\n            expect(response.fromCache).toBe(false);\n            expect(response.fetchParams).toEqual({ uuid: bookFixture.uuid });\n            expect(response.many).toEqual(false);\n\n            const book = response.object;\n\n            expect(book.title).toEqual(bookFixture.title);\n            expect(book.author).toEqual(bookFixture.author);\n            expect(book.isBestseller).toEqual(bookFixture.isBestseller);\n        });\n\n        it('should attempt to update a book model', async () => {\n            const bookFixture = {\n                uuid: '12345-123-4352-1234',\n                title: 'A Title',\n                author: 'Me',\n                isBestseller: false,\n            };\n\n            const transport = new coreapi.transports.HTTPTransport({\n                fetch: mockedFetch(JSON.stringify({ ...bookFixture }), 'application/json')\n            });\n            Hypnos.client.client = new coreapi.Client({ transports: [transport] });\n\n            const response = await Book.ps.update(bookFixture);\n\n            expect(response.fromCache).toBe(false);\n            expect(response.fetchParams).toEqual(bookFixture);\n            expect(response.many).toEqual(false);\n\n            const book = response.object;\n\n            expect(book.title).toEqual(bookFixture.title);\n            expect(book.author).toEqual(bookFixture.author);\n            expect(book.isBestseller).toEqual(bookFixture.isBestseller);\n        });\n    });\n\n    describe('Instance Tokens', () => {\n        it('should attempt to create a book instance', async () => {\n            const bookFixture = {\n                title: 'A Title',\n                author: 'Me',\n                isBestseller: false,\n            };\n\n            const transport = new coreapi.transports.HTTPTransport({\n                fetch: mockedFetch(JSON.stringify({ ...bookFixture }), 'application/json')\n            });\n            Hypnos.client.client = new coreapi.Client({ transports: [transport] });\n\n            const book = new Book(\n                bookFixture.title,\n                bookFixture.author,\n                bookFixture.isBestseller\n            );\n            const response = await book.ps.create();\n\n            expect(response.fromCache).toBe(false);\n            expect(response.fetchParams).toEqual(bookFixture);\n            expect(response.many).toEqual(false);\n\n            expect(book.title).toEqual(bookFixture.title);\n            expect(book.author).toEqual(bookFixture.author);\n            expect(book.isBestseller).toEqual(bookFixture.isBestseller);\n        });\n\n        it('should attempt to refresh a book instance that changed remotely', async () => {\n            const bookFixture = {\n                title: 'A Title',\n                author: 'Me',\n                isBestseller: false,\n            };\n\n            const transport = new coreapi.transports.HTTPTransport({\n                fetch: mockedFetch(JSON.stringify({ ...bookFixture }), 'application/json')\n            });\n            Hypnos.client.client = new coreapi.Client({ transports: [transport] });\n\n            const book = new Book(\n                'Some first draft title',\n                'N/A',\n                false\n            );\n            book.uuid = '09876543';\n            const response = await book.ps.refresh();\n\n            expect(response.fromCache).toBe(false);\n            expect(response.fetchParams.uuid).toEqual(book.uuid);\n            expect(response.many).toEqual(false);\n\n            expect(response.object.title).toEqual(bookFixture.title);\n            expect(response.object.author).toEqual(bookFixture.author);\n            expect(response.object.isBestseller).toEqual(bookFixture.isBestseller);\n        });\n\n        it('should attempt to save a book instance', async () => {\n            const bookFixture = {\n                title: 'A Title',\n                author: 'Me',\n                isBestseller: false,\n            };\n\n            const transport = new coreapi.transports.HTTPTransport({\n                fetch: mockedFetch(JSON.stringify({ ...bookFixture }), 'application/json')\n            });\n            Hypnos.client.client = new coreapi.Client({ transports: [transport] });\n\n            const book = new Book(\n                bookFixture.title,\n                bookFixture.author,\n                bookFixture.isBestseller\n            );\n            const response = await book.ps.create();\n\n            expect(response.fromCache).toBe(false);\n            expect(response.fetchParams).toEqual(bookFixture);\n            expect(response.many).toEqual(false);\n\n            expect(book.title).toEqual(bookFixture.title);\n            expect(book.author).toEqual(bookFixture.author);\n            expect(book.isBestseller).toEqual(bookFixture.isBestseller);\n\n            // Alter and save\n            book.title = 'This new value';\n            const saveResponse = await book.ps.save();\n\n            expect(saveResponse.fromCache).toBe(false);\n            expect(saveResponse.fetchParams.uuid).toEqual(book.uuid);\n            expect(saveResponse.fetchParams.title).toEqual('This new value');\n            expect(saveResponse.many).toEqual(false);\n        });\n\n        it('should attempt to partially update a book instance', async () => {\n            const bookFixture = {\n                uuid: '12345-123-4352-1234',\n                title: 'A Title',\n                author: 'Me',\n                isBestseller: false,\n            };\n\n            const transport = new coreapi.transports.HTTPTransport({\n                fetch: mockedFetch(JSON.stringify({ ...bookFixture }), 'application/json')\n            });\n            Hypnos.client.client = new coreapi.Client({ transports: [transport] });\n\n            const book = new Book(\n                bookFixture.title,\n                bookFixture.author,\n                bookFixture.isBestseller\n            );\n            book.uuid = bookFixture.uuid;\n            const response = await book.ps.create();\n\n            expect(book.title).toEqual(bookFixture.title);\n\n            // Alter and save\n            book.title = 'This new value';\n            const saveResponse = await book.ps.save(['title', 'uuid']);\n\n            expect(saveResponse.fromCache).toBe(false);\n            expect(saveResponse.fetchParams.uuid).toEqual(book.uuid);\n            expect(saveResponse.fetchParams.title).toEqual('This new value');\n            expect(saveResponse.fetchKeys[1]).toEqual('partialUpdate');\n            expect(saveResponse.many).toEqual(false);\n        });\n\n        describe('Cache Dependencies', () => {\n            it('should attempt to create an author instance and flush the cached books', async () => {\n                const bookFixtures = [\n                    {\n                        title: 'A Title',\n                        author: 'Me',\n                        isBestseller: false,\n                    },\n                    {\n                        title: 'Another Title',\n                        author: 'You',\n                        isBestseller: true,\n                    },\n                ];\n\n                const transport = new coreapi.transports.HTTPTransport({\n                    fetch: mockedFetch(JSON.stringify({ ...bookFixtures }), 'application/json')\n                });\n                Hypnos.client.client = new coreapi.Client({ transports: [transport] });\n\n                // Fetch all books.\n                const response1 = await Book.ps.list();\n                expect(response1.fromCache).toBe(false);\n\n                // Fetch again, this time from the cache.\n                const response2 = await Book.ps.list();\n                expect(response2.fromCache).toBe(true);\n\n                // List the authors, which SHOULD NOT clear the book cache.\n                const response3 = await Author.ps.list();\n\n                const response4 = await Book.ps.list();\n                expect(response4.fromCache).toBe(true);\n\n                // Update an author, which SHOULD clear the book and the author cache.\n                const response5 = await Author.ps.create({\n                    firstName: 'test',\n                    lastName: 'testersson'\n                });\n\n                const response6 = await Book.ps.list();\n                expect(response6.fromCache).toBe(false);\n\n                const response7 = await Author.ps.list();\n                expect(response7.fromCache).toBe(false);\n\n                // And if we were to request the book list agin, it SHOULD be cached.\n                const response8 = await Book.ps.list();\n                expect(response8.fromCache).toBe(true);\n            });\n        });\n    });\n});\n",
    "static": true,
    "longname": "/Users/ifoundit/Projects/adventurers_codex/hypnos/src/tokens.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 132,
    "kind": "variable",
    "name": "defaultConfiguration",
    "memberof": "src/tokens.spec.js",
    "static": true,
    "longname": "src/tokens.spec.js~defaultConfiguration",
    "access": "public",
    "export": false,
    "importPath": "hypnos/src/tokens.spec.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "{\"schema\": *, \"credentials\": *, \"cacheConfig\": *}"
      ]
    },
    "ignore": true
  },
  {
    "kind": "index",
    "content": "# Hypnos - A Better Way to REST\n\n[![Build Status](https://travis-ci.com/adventurerscodex/hypnos.svg?branch=master)](https://travis-ci.com/adventurerscodex/hypnos)\n[![Coverage Status](https://coveralls.io/repos/github/adventurerscodex/hypnos/badge.svg)](https://coveralls.io/github/adventurerscodex/hypnos)\n\n**This project is currently in development.**\n\n*An API client and ORM for CoreAPI powered REST APIs.*\n\nHypnos is a light-weight ORM and API Client for Web apps. It provides a clean and concise way to interact with your API data **without any URLs or manual requests**. In a way, it is very similar to `Apollo` for GraphQL, but more inspired by projects like `Django ORM` and `SQLAlchemy`.\n\nFinally, web apps can have a real model layer.\n\n\nOverview\n--------\n\nHypnos lets you feel like you're developing with a real database. Using the power of [CoreAPI][coreapi] things like URLs and request methods are a thing of the past. You define a CoreAPI compatible data model in your API (via something like Django-REST framework) and point Hypnos at your API schema and Hypnos will take care of the rest.\n\n\n### Features\n\nBesides making your code easier to understand, Hypnos also has some really cool features out of the box!\n\n- **Built-in pagination support** for things like infinite scrolling.\n- **Request caching** to prevent repeated, identical queries to your API.\n- **Cache Dependency Tracking** so that when a record gets updated, Hypnos won't serve any cached data for its dependents.\n- **Smart Requests**: Behind the scenes Hypnos will do the smart thing: if you tell Hypnos which fields to update, Hypnos will transform the request from `PUT` to `PATCH`.\n- **Need custom behavior?** Hypnos allows you to query your API directly in case you still need to do something we don't support.\n\n\n[coreapi]: http://www.coreapi.org\n\n\n### Example\n\n    // book.js\n\n    import { Model } from 'hypnos';\n\n    class Book extends Model {\n        // The CoreAPI keys/path for this resource.\n        __skeys__ = ['book'];\n\n        // Properties from your API are mapped in dynamially so you only\n        // need to specify your computed properties.\n        // No need to repeat your data model!\n\n        get summary() {\n            const {title, type, author} = this;\n            return `${title} is a thrilling new ${type} from ${author}`;\n        }\n\n        toggleFavorite() {\n            this.favorite = !this.favorite;\n        }\n    }\n\n    // service/component/view_controller.js\n\n    import Hypnos from 'hypnos';\n\n    Book.ps.retrieve({ id: '1234' }).then(response => {\n         const book = response.object;\n         // Update the local properties of the book object.\n         book.title = 'My new favorite book';\n\n         // Persist your changes back to the API.\n         book.ps.save();\n\n         // ...You can even refresh your local object from the API.\n         book.ps.refresh();\n\n         // ...Or delete it easily.\n         book.ps.delete();\n    });\n\n    // OR use with async/await!\n    const response = await Book.ps.retrieve({ id: '1234' });\n\n\nSmart Caching\n-------------\n\nHypnos is smart. If you specify which resources depend on each other, then Hypnos will automatically clear data from the cache when a record's dependencies are updated.\n\n### Example\n\n    /* book.js */\n\n    class Book extends Model {\n        __skeys__ = ['book'];\n        __dependents__ = [Author];\n        // ...\n    }\n\n    /* author.js */\n\n    class Author extends Model {\n        __skeys__ = ['book'];\n        __dependents__ = [Book];\n        // ...\n    }\n\n    /* service/component/view_controller.js */\n\n    // Listing and retrieving records (by default) doesn't invalidate the cache.\n\n    const { objects: books } = await Book.ps.list();        // From the network\n    const { objects: authors } = await Author.ps.list();    // From the network\n    const { objects: books } = await Book.ps.list();        // From the cache\n\n    // But write operations do!\n\n    const { object: book } = await Book.ps.update({         // Clear the Author and book cache!\n        id: '1234',\n        title: 'A new title!'\n    });\n    const { objects: books } = await Book.ps.list();        // From the network\n\n    // Of course, you can always override these defaults\n    const { objects: books } = await Book.ps.list(          // From the network\n        // Query parameters\n        { search: 'over the rainbow' },\n        // Don't map the result to a Book instance just return raw data.\n        true,\n        // Don't use the cache.\n        false,\n        // Force clear the dependents' cache.\n        true\n    );\n\n\nConfiguring Hypnos\n------------------\n\nHypnos must be configured before accessing the `.client` lazy property. Hypnos' configuration object takes 3 special parameters, each with their own formats, fed to Hypnos' dependencies.\n\n- `credentials`: Is the credentials configuration for the API. This takes the format of the CoreAPI credentials object.\n- `schema`: The CoreAPI schema document.\n- `cacheConfig`: The cache configuration which should take the format found in the `node-cache` documentation.\n\n**IMPORTANT:** Caching is disabled unless a `cacheConfig` is specified.\n\n\n    Hypnos.configuration = {\n        credentials: {\n            scheme: 'Bearer',\n            token: '--super-secret-token--',\n        },\n        schema: getSchema(),\n        cacheConfig: {\n            stdTTL: 120,\n            checkperiod: 10\n        }\n    };\n\n",
    "longname": "/Users/ifoundit/Projects/adventurers_codex/hypnos/README.md",
    "name": "./README.md",
    "static": true,
    "access": "public"
  },
  {
    "kind": "packageJSON",
    "content": "{\n  \"name\": \"hypnos\",\n  \"version\": \"0.1.0\",\n  \"description\": \"An API client and ORM for CoreAPI powered REST APIs.\",\n  \"main\": \"./lib/index.js\",\n  \"scripts\": {\n    \"build\": \"npm run build:lib\",\n    \"build:lib\": \"cross-env BABEL_ENV=production babel src --out-dir lib\",\n    \"clean\": \"rimraf dist es lib\",\n    \"prepublish\": \"npm run clean && npm run build && npm run doc\",\n    \"test\": \"cross-env NODE_ENV=test jest --config=jest.json --coverage\",\n    \"lint\": \"./node_modules/eslint/bin/eslint.js -c ./.eslintrc.yml --ext .jsx,.js src\",\n    \"coveralls\": \"cat ./coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js\",\n    \"doc\": \"esdoc\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/adventurerscodex/hypnos.git\"\n  },\n  \"keywords\": [\n    \"api\",\n    \"client\",\n    \"REST\",\n    \"Django-REST\",\n    \"ORM\",\n    \"CoreAPI\"\n  ],\n  \"author\": \"Brian Schrader\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/adventurerscodex/hypnos/issues\"\n  },\n  \"homepage\": \"https://github.com/adventurerscodex/hypnos#readme\",\n  \"optionalDependencies\": {\n    \"knockout\": \"^3.5.0-beta\"\n  },\n  \"dependencies\": {\n    \"node-cache\": \"^4.2.0\",\n    \"object-hash\": \"^1.3.0\",\n    \"uuid\": \"^3.3.2\"\n  },\n  \"devDependencies\": {\n    \"babel\": \"^6.23.0\",\n    \"babel-cli\": \"^6.26.0\",\n    \"babel-core\": \"^6.26.0\",\n    \"babel-eslint\": \"^9.0.0\",\n    \"babel-loader\": \"^7.1.2\",\n    \"babel-plugin-transform-class-properties\": \"^6.24.1\",\n    \"babel-preset-env\": \"^1.6.1\",\n    \"babel-preset-es2015\": \"^6.24.1\",\n    \"babel-preset-stage-0\": \"^6.24.1\",\n    \"babel-register\": \"^6.26.0\",\n    \"coreapi\": \"^0.1.1\",\n    \"coveralls\": \"^3.0.2\",\n    \"cross-env\": \"^5.0.5\",\n    \"esdoc\": \"^1.0.4\",\n    \"esdoc-ecmascript-proposal-plugin\": \"^1.0.0\",\n    \"esdoc-standard-plugin\": \"^1.0.0\",\n    \"eslint\": \"^5.5.0\",\n    \"eslint-plugin-import\": \"^2.14.0\",\n    \"jest\": \"^20.0.4\",\n    \"rimraf\": \"^2.6.1\",\n    \"webpack\": \"^4.1.1\",\n    \"webpack-cli\": \"^2.0.11\"\n  }\n}\n",
    "longname": "/Users/ifoundit/Projects/adventurers_codex/hypnos/package.json",
    "name": "package.json",
    "static": true,
    "access": "public"
  }
]